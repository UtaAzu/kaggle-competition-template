#!/usr/bin/env python3
import json
from pathlib import Path
from datetime import datetime

ROOT = Path(__file__).resolve().parents[1]
EXPS = ROOT / "experiments"
INDEX = EXPS / "INDEX.md"

SKIP_DIRS = {".git", ".github", ".chats", ".prompts", "_template"}
DATE_KEYS = ["created_at", "date", "timestamp", "datetime"]
TITLE_KEYS = ["title", "name", "desc", "description", "experiment_id"]
METRIC_KEYS = ["score", "val_score", "metric", "val_metric", "public_lb"]


def read_json(p: Path) -> dict:
    try:
        with p.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def fmt_date(v):
    if not v:
        return "-"
    if isinstance(v, (int, float)):
        try:
            return datetime.fromtimestamp(v).strftime("%Y-%m-%d")
        except Exception:
            return str(v)
    for fmt in ("%Y-%m-%d", "%Y/%m/%d", "%Y-%m-%d %H:%M", "%Y/%m/%d %H:%M:%S", "%Y-%m-%dT%H:%M:%S"):
        try:
            return datetime.strptime(str(v)[:19], fmt).strftime("%Y-%m-%d")
        except Exception:
            continue
    return str(v)


def first_key(d: dict, keys):
    for k in keys:
        if k in d and d[k] not in (None, ""):
            return d[k]
    return None


def collect():
    rows = []
    if not EXPS.exists():
        return rows
    for p in sorted(EXPS.iterdir()):
        if not p.is_dir():
            continue
        name = p.name
        if name.startswith(".") or name in SKIP_DIRS:
            continue
        if name.upper() == "INDEX.md":
            continue
        if name.startswith("_"):
            continue
        run = read_json(p / "run.json")
        date = fmt_date(first_key(run, DATE_KEYS))
        title = first_key(run, TITLE_KEYS) or name
        
        # Extract metric value from various possible locations
        metric_value = None
        # First try direct metric keys
        for k in METRIC_KEYS:
            if k in run:
                metric_value = run[k]
                break
        
        # If not found, try nested structures
        if metric_value is None:
            # Check CV mean score
            if "cv" in run and isinstance(run["cv"], dict):
                cv = run["cv"]
                if "mean" in cv:
                    metric_value = cv["mean"]
            
            # Check leaderboard public_lb
            if metric_value is None and "leaderboard" in run and isinstance(run["leaderboard"], dict):
                lb = run["leaderboard"]
                if "public_lb" in lb:
                    metric_value = lb["public_lb"]
        
        metric = metric_value if metric_value is not None else "-"
        notes = (run.get("notes") or "").strip()
        if len(notes) > 60:
            notes = notes[:57] + "..."
        rows.append({
            "name": name,
            "title": title,
            "date": date,
            "metric": metric,
            "notes": notes,
        })
    # Sort by date desc if available, then name desc
    def to_key(r):
        d = r["date"]
        try:
            return datetime.strptime(d, "%Y-%m-%d"), r["name"]
        except Exception:
            return datetime.min, r["name"]
    rows.sort(key=to_key, reverse=True)
    return rows


def render(rows):
    lines = []
    lines.append("# Experiments Index")
    lines.append("")
    lines.append("> This file is auto-generated by scripts/update_experiment_index.py. Do not edit by hand.")
    lines.append("")
    if not rows:
        lines.append("_No experiments found._")
        return "\n".join(lines) + "\n"
    latest = rows[0]["name"]
    def to_float(x):
        try:
            return float(x)
        except Exception:
            return None
    numeric = [r for r in rows if to_float(r["metric"]) is not None]
    best = None
    if numeric:
        best = max(numeric, key=lambda r: float(r["metric"]))["name"]
    lines.append(f"- Latest: [{latest}](./{latest})")
    if best:
        lines.append(f"- Best: [{best}](./{best})")
    lines.append("")
    lines.append("| ID | Title | Date | Metric | Notes |")
    lines.append("|---|---|---:|---:|---|")
    for r in rows:
        link = f"[{r['name']}](./{r['name']})"
        title = str(r["title"]).replace("|", "\\|")
        notes = str(r["notes"]).replace("|", "\\|")
        lines.append(f"| {link} | {title} | {r['date']} | {r['metric']} | {notes} |")
    lines.append("")
    return "\n".join(lines) + "\n"


def main():
    rows = collect()
    INDEX.parent.mkdir(parents=True, exist_ok=True)
    INDEX.write_text(render(rows), encoding="utf-8")
    print(f"Wrote {INDEX.relative_to(ROOT)} with {len(rows)} rows")


if __name__ == "__main__":
    main()